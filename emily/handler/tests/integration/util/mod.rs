//! Testing utilities.
//! TODO(283, TBD): Use openapi generated client instead of bespoke methods.

use std::collections::HashMap;

use emily_handler::api::models::{
    chainstate::Chainstate,
    common::Status,
    deposit::{
        requests::CreateDepositRequestBody,
        responses::{CreateDepositResponse, GetDepositsResponse},
        DepositInfo,
    },
    withdrawal::{
        requests::CreateWithdrawalRequestBody,
        responses::{CreateWithdrawalResponse, GetWithdrawalsResponse},
        WithdrawalInfo,
    },
};
use reqwest::Client;
use serde::{Deserialize, Serialize};

/// Test constants module.
pub mod constants;

use constants::{
    ALL_STATUSES, EMILY_CHAINSTATE_ENDPOINT, EMILY_DEPOSIT_ENDPOINT, EMILY_TESTING_ENDPOINT,
    EMILY_WITHDRAWAL_ENDPOINT,
};

pub fn assert_eq_pretty<T>(actual: T, expected: T)
where
    T: Serialize + std::fmt::Debug + Eq,
{
    // Assert both objects equal with a prettier output string.
    assert_eq!(
        actual,
        expected,
        "Actual:\n{}\nExpected:\n{}",
        serde_json::to_string_pretty(&actual).unwrap(),
        serde_json::to_string_pretty(&expected).unwrap()
    );
}

/// Test client to make API calls within integration tests. This takes the place of what
/// will eventually be an autogenerated OpenAPI client before the OpenAPI client is
/// properly generated.
///
/// The existance of this class is tech-debt.
pub struct TestClient {
    pub inner: Client,
}

/// Test client implementation.
impl TestClient {

    /// Create the test client.
    pub fn new() -> Self {
        TestClient {
            inner: Client::new()
        }
    }

    /// Sets up the test environment.
    pub async fn setup_test(&self) {
        self.reset_environment().await;
    }

    pub async fn reset_environment(&self) {
        let endpoint: String = format!("{EMILY_TESTING_ENDPOINT}/wipe");
        self.inner
            .post(&endpoint)
            .send()
            .await
            .expect(&format!("Failed to perform wipe api call: [{endpoint}]"));
    }

    /// Create deposit.
    pub async fn create_deposit(
        &self,
        request: CreateDepositRequestBody,
    ) -> CreateDepositResponse {
        create_xyz(&self.inner, EMILY_DEPOSIT_ENDPOINT, request).await
    }

    /// Create withdrawal.
    pub async fn create_withdrawal(
        &self,
        request: CreateWithdrawalRequestBody,
    ) -> CreateWithdrawalResponse {
        create_xyz(&self.inner, EMILY_WITHDRAWAL_ENDPOINT, request).await
    }

    /// Create chainstate.
    pub async fn create_chainstate(&self, request: Chainstate) -> Chainstate {
        create_xyz(&self.inner, EMILY_CHAINSTATE_ENDPOINT, request).await
    }

    /// Get all withdrawals.
    pub async fn get_all_withdrawals(&self) -> Vec<WithdrawalInfo> {
        let mut all_withdrawals: Vec<WithdrawalInfo> = Vec::new();
        for status in ALL_STATUSES {
            all_withdrawals.extend(
                self.get_all_withdrawals_with_status(status)
                    .await
                    .into_iter(),
            );
        }
        all_withdrawals
    }

    /// Gets all withdrawals with a specified status.
    pub async fn get_all_withdrawals_with_status(
        &self,
        status: &Status,
    ) -> Vec<WithdrawalInfo> {
        // Get all withdrawals with the given status.
        get_all_xyz_with_status::<GetWithdrawalsResponse, WithdrawalInfo>(
            &self.inner,
            EMILY_WITHDRAWAL_ENDPOINT,
            base_query_from_status(status),
            |response: &GetWithdrawalsResponse| response.next_token.clone(),
            |response: &GetWithdrawalsResponse| response.withdrawals.clone(),
        )
        .await
    }

    /// Get all deposits.
    pub async fn get_all_deposits(&self) -> Vec<DepositInfo> {
        let mut all_deposits: Vec<DepositInfo> = Vec::new();
        for status in ALL_STATUSES {
            all_deposits.extend(
                self.get_all_deposits_with_status(status)
                    .await
                    .into_iter(),
            );
        }
        all_deposits
    }

    /// Gets all deposits with a specified status.
    pub async fn get_all_deposits_with_status(&self, status: &Status) -> Vec<DepositInfo> {
        // Get all deposits with the given status.
        get_all_xyz_with_status::<GetDepositsResponse, DepositInfo>(
            &self.inner,
            EMILY_DEPOSIT_ENDPOINT,
            base_query_from_status(status),
            |response: &GetDepositsResponse| response.next_token.clone(),
            |response: &GetDepositsResponse| response.deposits.clone(),
        )
        .await
    }

}


// Test utilities
// -----------------------------------------------------------------------------

/// Generic create function.
async fn create_xyz<T, R>(client: &Client, endpoint: &str, request: T) -> R
where
    T: Serialize,
    R: for<'de> Deserialize<'de>,
{
    client
        .post(endpoint)
        .json(&request)
        .send()
        .await
        .expect(&format!(
            "Failed to perform create Emily API call: [{endpoint}]"
        ))
        .json()
        .await
        .expect(&format!(
            "Failed to deserialize response from create Emily API call: [{endpoint}]"
        ))
}

// Get Many
// -----------------------------------------------------------------------------

/// Generic get all function that will get all of the items from a specific API query
/// with a given status.
async fn get_all_xyz_with_status<R, I>(
    client: &Client,
    endpoint: &str,
    base_query: HashMap<String, String>,
    extract_token: fn(&R) -> Option<String>,
    extract_items: fn(&R) -> Vec<I>,
) -> Vec<I>
where
    R: for<'de> Deserialize<'de>,
{
    // Aggregate list to get accumulate items.
    let mut all_items: Vec<I> = Vec::new();
    // Make initial query.
    let mut response = client
        .get(endpoint)
        .query(&base_query.clone().into_iter().collect::<Vec<_>>())
        .send()
        .await
        .expect(&format!(
            "Failed to perform get many Emily API call: [{endpoint}, {base_query:?}]"
        ))
        .json()
        .await
        .expect(&format!(
            "Failed to deserialize response from get many Emily API call: [{endpoint}, {base_query:?}]"
        ));
    // Add items from latest response to accumulator list.
    all_items.extend(extract_items(&response).into_iter());
    // Loop until the `next_token` is null.
    while let Some(next_token) = extract_token(&response) {
        // Add next token to the query.
        let mut query = base_query.clone();
        query.insert("nextToken".to_string(), next_token.clone());
        response = client
            .get(endpoint)
            .query(&query.into_iter().collect::<Vec<_>>())
            .send()
            .await
            .expect(&format!(
                "Failed to perform get many Emily API call: [{endpoint}, {base_query:?}]"
            ))
            .json()
            .await
            .map_err(|error| {
                eprintln!("{:?}", error);
                error
            })
            .expect(&format!(
                "Failed to deserialize response from get many Emily API call: [{endpoint}, {base_query:?}]"
            ));
        // Add items from latest response to accumulator list.
        all_items.extend(extract_items(&response).into_iter());
    }
    all_items
}

/// Creates a base query from a provided status.
fn base_query_from_status(status: &Status) -> HashMap<String, String> {
    let mut base_query: HashMap<String, String> = HashMap::new();
    base_query.insert(
        "status".to_string(),
        serialized_status(status),
    );
    base_query
}

/// Creates a serialized status.
fn serialized_status(status: &Status) -> String {
    serde_json::to_string(status)
        .expect(&format!("Status param {status:?} impossibly failed serialization."))
        // Trim the quotes on either side of the serialization so that
        // there don't end up being multiple quotes in the serialization
        // of the `status` enum.
        .trim_matches('"')
        .to_string()
}
